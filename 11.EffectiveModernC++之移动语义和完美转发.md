## Item 23: Understand `std::move` and `std::forward`

### 如何理解`std::move`和`std::forward`：

1. `std::move`不移动（move）任何东西，`std::forward`也不转发（forward）任何东西，仅仅是**执行转换（cast）的函数**（事实上是函数模板）;
2. `std::move`无条件的将它的实参转换为右值，而`std::forward`只在特定情况满足时下进行转换。

`std::move`在 C++11 中的实现方式： 注意到该函数的返回值类型是`std::remove_reference<T>::type&&`，一个右值引用。

```c++
template <typename T>
typename std::remove_reference<T>::type&& move(T&& param) {
  using ReturnType = typename std::remove_reference<T>::type&&;
  return static_cast<ReturnType>(param);
}
```

`std::move`在 C++14 中的实现方式：使用`decltype(auto)`自动推到返回值类型。

```c++
template <typename T>
decltype(auto) move(T&& param) {
  using ReturnType = std::remove_reference_t<T>&&;
  return static_cast<ReturnType>(param);
}
```

### `remove_reference`是啥

其中，`remove_reference`的实现代码如下所示，其实就是针对不同的`T`,`T&`,`T&&`，均可以返回去掉引用修饰符的`T`（当然`const`属性还是会被保留下来）。

```c++
template<class T> struct remove_reference { typedef T type; };
template<class T> struct remove_reference<T&> { typedef T type; };
template<class T> struct remove_reference<T&&> { typedef T type; };

remove_reference<Test>::type a1;          // Test a1;
remove_reference<const Test>::type a2;    // const Test a2;
remove_reference<Test&>::type b1;         // Test b1;
remove_reference<const Test&>::type b2;   // const Test b2;
remove_reference<Test&&>::type c1;        // Test c1;
remove_reference<const Test&&>::type c2;  // const Test c2;
```

### `std::move`本质上做了啥

**注意**：`std::move`只是把一个对象`cast`成了一个可供移动的候选者，真正的移动操作不一定会发生。举个例子：

```c++
class Test {
 public:
  Test() { std::cout << "default constructor\n"; }
  Test(const Test& other) { std::cout << "copy constructor\n"; }
  void operator=(const Test& other) { std::cout << "copy operator=\n"; }
  Test(Test&& other) { std::cout << "move constructor\n"; }
  void operator=(Test&& other) { std::cout << "move operator=\n"; }
  ~Test() = default;
};

class Sample {
 public:
  /**
   * 这里虽然使用了 std::move，但是并不会调用 test 的移动构造
   * 因为这里 test 是 const 修饰的；而 Test 类的移动构造函数的参数是非 const 的。
   */
  Sample(const Test test) : m_test(std::move(test)) {}

 public:
  Test m_test;
};

int main() {
  Test test;
  Sample sample(test);
  // default constructor
  // copy constructor
  // copy constructor
}
```

所以说，要注意这几点：

1. 不要在你希望能移动对象的时候，声明他们为`const`。对`const`对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move`不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。

### `std::forward`本质上又做了啥

一般用法：**引用转发**，最常见的情景是一个模板函数，接收一个通用引用形参，并将该参数传递给 内部另外的函数。

```c++
void process(const Test& lvalArg) { std::cout << "dealing with lvalue\n"; }
void process(Test&& rvalArg) { std::cout << "dealing with rvalue\n"; }

/**
 * 注：即使传入参数 param 为右值，这里的 param 自己本身依旧是个左值；
 * 那 process 在未引用转发时，调用的一直都是 void process(const Test& lvalArg);
 * 为了使得内部函数 process 调用时也可以保持 param 的左右值属性，固使用 std::forward
 */
template <typename T>
void logAndProcess(T&& param) {
  auto now = std::chrono::system_clock::now();
  auto now_time = std::chrono::system_clock::to_time_t(now);
  std::cout << "Calling process time:" << std::ctime(&now_time);
  process(std::forward<T>(param));
}

int main() {
  Test test;
  logAndProcess(test);            // 传入左值参数，内部函数 process 处理的参数 param 同样为左值
  logAndProcess(std::move(test));  // 传入右值参数，内部函数 process 处理的参数 param 同样为右值
}
```

## Item 24: Distinguish universal references from rvalue references

通用引用：其类型声明看起来像一个右值引用`T&&`，但实际上它可能是一个左值引用或右值引用。这取决于所赋值的表达式。有两种情况：

1. 函数模板形参

```c++
template<typename T>
void f(T&& param);
```

2. `auto`声明符号

```c++
auto&& var2 = var1;
```

注意：通用引用必须是需要类型推导的。且传入值为右值时，`param`会推导为右值引用`T&&`；传入值为左值时，`param`会推导为左值引用`T&`。

注意以下类型非通用引用：

1. 形式必须满足`T&&`：`template <typename T> void f(std::vector<T>&& param);`，其中，`param`是一个右值引用；
2. 添加`const`修饰符：`template <typename T> void f(const T&& param);`，其中，`param`是一个右值引用（即使仅添加了`const`修饰符）；
3. 未类型推导：下面的代码中即使函数`push_back`的形参类型为`T&&`，但这里也并非通用引用；因为这里未涉及到类型推导，我们在定义该`vector`的时候，`T`的类型就已经确定了。

```c++
template<class T, class Allocator = allocator<T>>
class vector {
public:
    void push_back(T&& x);
}
```

但是，`std::vector`内部的`emplace_back`确实是通用引用；因为这里的`Args`参数是独立于`T`的，是针对函数`emplace_back`的需要推导的模板参数。

```c++
template<class T, class Allocator = allocator<T>>
class vector {
public:
    template <class... Args>
    void emplace_back(Args&&... args);
};
```

## Item 25: Use `std::move` on rvalue references, `std::forward` on universal references

对右值引用使用`std::move`，对通用引用使用`std::forward`。

下面通过代码来解释这两个情况是什么意思。

```c++
class Test {
 public:
  Test() { std::cout << "default constructor\n"; }
  Test(const Test& other) { std::cout << "copy constructor\n"; }
  void operator=(const Test& other) { std::cout << "copy operator=\n"; }
  Test(Test&& other) { std::cout << "move constructor\n"; }
  void operator=(Test&& other) { std::cout << "move operator=\n"; }
  ~Test() = default;
};

class Sample {
 public:
  Sample() = default;

  /**
   * 形参为右值引用时，将形参传递给其他对象时尽量利用其右值性，使用 std::move
   */
  Sample(Test&& test) : m_test(std::move(test)) {}

  /**
   * 形参为通用引用时，将形参传递给其他对象时，使用 std::forward（因为你也不确定形参是左值还是右值）
   */
  template <typename T>
  void SetTest(T&& test) {
    m_test = std::forward<T>(test);
  }

  Test ReturnTest1(Test&& test) { return std::move(test); }

  template <typename T>
  decltype(auto) ReturnTest2(T&& test) {
    return std::forward<T>(test);
  }

 public:
  Test m_test;
};

int main() {
  Test test1;
  Sample sample;
  std::cout << "--------\n";
  Test t1 = sample.ReturnTest2(test1);
  std::cout << "--------\n";
  Test t2 = sample.ReturnTest2(Test());
  // default constructor
  // default constructor
  // --------
  // copy constructor
  // --------
  // default constructor
  // move constructor
}
```

这里需要注意字符串字面量的右值引用和通用引用形式：毕竟本质上字符串字面量的类型还是 `const char[]`

所以说，需要注意通用引用和右值引用在这方面上的区别，通用引用还是存在类型推导的。

```c++
class Sample {
 public:
  Sample() = default;

  void SetName(const std::string& name) { m_name = name; }

  void SetName(std::string&& name) { m_name = std::move(name); }

  template <typename T>
  void SetName2(T&& name) {
    m_name = std::forward<T>(name);
  }

 public:
  std::string m_name;
};

int main() {
  Sample sample;
  // void Sample::SetName(std::__1::string &&name)，这里类型是 const char [12]，会先调用 string 的构造函数生成一个临时对象，再调用 SetName 的右值形式
  sample.SetName("hello world");
  // void Sample::SetName2<const char (&)[12]>(const char (&name)[12])，这里通用引用会自动推导出类型 const char [12]
  sample.SetName2("hello world");
}
```

这个注意点尤其是在`std::vector`中适用：`push_back`和`emplace_back`

```c++
int main() {
  std::vector<std::string> strs;
  // inline void push_back(std::string &&__x)
  // 会先经过 const char [] 到 std::string 的构造，再调用右值形式的 push_back
  strs.push_back("hello");
  // inline void emplace_back<const char (&)[6]>(const char (&__args)[6])
  // 直接调用 emplace_back
  strs.emplace_back("world");
}
```

## Item 26: Avoid overloading on universal references

需要避免在参数为通用引用的函数上重载。

主要原因是用户自定义的重载函数，因为一些参数的类型在调用时会发生隐式转换，这种场景会优先匹配到通用引用的函数，而恰好通用引用的函数行为和用户期许隐式转换调用的函数行为不一致。

对于通用引用形式形参来说，几乎可以精确匹配任何类型的实参。主要是有三种场景，普通函数、构造函数、继承场景；

### 1. 对于普通函数

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
std::vector<std::string> names;

// 参数为通用引用的函数
template <typename T>
void LogAndAdd(T&& name) {
  names.emplace_back(std::forward<T>(name));
}

//  重载通用引用的函数
void LogAndAdd(int idx) { names.emplace_back(map_idx_2_name[idx]); }

int main() {
  // 以下三种情况的通用引用函数调用形式，说明了精确推导
  std::string petName("Darla");
  LogAndAdd(petName);                    // 函数模板实例化为：void LogAndAdd<std::string &>(std::string &name)
  LogAndAdd(std::string("Persephone"));  // 函数模板实例化为：void LogAndAdd<std::string>(std::string &&name)
  LogAndAdd("Patty Dog");                // 函数模板实例化为：void LogAndAdd<const char (&)[10]>(const char (&name)[10])

  int idx1 = 1;
  LogAndAdd(idx1);  // 精确调用 void LogAndAdd(int idx)
  short idx2 = 1;
  // 根据正常的重载解决规则，精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。
  // 这里会匹配到 void LogAndAdd(T&& name)，并不会匹配到 void LogAndAdd(int idx)，所以会报错
  LogAndAdd(idx2);  // 函数模板实例化为：void LogAndAdd<short &>(short &name)
}
```

### 2. 再就是构造函数，

```c++
class Sample {
 public:
  // 参数为通用引用的构造函数
  template <typename T>
  Sample(T&& test) : m_test(std::forward<T>(test)) {}

  // 重载通用引用的构造函数
  Sample(int idx) : m_test(map_idx_2_name[idx]) {}

  // 拷贝构造函数和移动构造函数可能非用户定义，而是编译器自动生成的；如果编译器自动生成就很容易被我忽略掉
  Sample(const Sample& other) {}
  Sample(Sample&& other) {}

 public:
  std::string m_test;
};

int main() {
  int a = 1;
  short b = 2;
  Sample sample1(a);
  Sample sample2(b);  // 报错：调用Sample(T&& test)，无法直接用int来构造string

  Sample s1(a);
  Sample s2(s1);  // 报错：调用Sample(T&& test)，尝试使用 s1 来初始化 m_test，所以报错
  // 这里为啥报错？因为 s1 的类型是非 const 的，而拷贝构造函数是 const 的，所以会去匹配通用引用形式的构造函数
}
```

### 3. 存在继承关系的构造函数

首先，在存在继承关系的场景下，当创建派生类的对象时，C++会默认调用基类的默认构造函数。这是因为派生类对象包含了基类的数据成员，所以需要初始化这些成员。

那就存在这种情况，当基类中的构造函数参数为通用引用时，在派生类中用户自定义基类构造会出现通用引用匹配问题。如下面代码所示，

`Person`类中`Person(T&& n) : name(std::forward<T>(n))`函数未被注释时，派生类`SpecialPerson`的两种调用父类构造方法：`Person(rhs)`和`Person(std::move(rhs))`，因为类型还是`SpecialPerson`，还是会命中`Person`类的通用引用形式形参的构造函数。自然就会出现问题了。

```c++
class Person {
 public:
  // 需要注释与不注释下面的代码看程序输出
  template <typename T>
  Person(T&& n) : name(std::forward<T>(n)) {
    std::cout << "Person(T&& n)\n";
  }
  Person() {}
  Person(const Person& person) { std::cout << "Person(const Person& person)\n"; }
  Person(Person&& person) { std::cout << "Person(Person &&person)\n"; }

 private:
  std::string name;
};

class SpecialPerson : public Person {
 public:
  SpecialPerson() {}
  SpecialPerson(const SpecialPerson& rhs) : Person(rhs) {}
  SpecialPerson(SpecialPerson&& rhs) : Person(std::move(rhs)) {}
};

int main() {
  SpecialPerson sp0 = SpecialPerson();
  SpecialPerson sp1 = SpecialPerson(sp0);             // Person没有通用引用构造函数时，调用父类的拷贝构造函数：Person(const Person& person)
  SpecialPerson sp2 = SpecialPerson(std::move(sp0));  // Person没有通用引用构造函数时，调用父类的移动构造函数：Person(Person &&person)

  SpecialPerson sp1 = SpecialPerson(sp0);             // Person有通用引用构造函数时，会类型推导然后调用通用引用类型的构造函数
  SpecialPerson sp2 = SpecialPerson(std::move(sp0));  // Person有通用引用构造函数时，会类型推导然后调用通用引用类型的构造函数
}
```


## Item 27: Familiarize yourself with alternatives to overloading on universal references

对使用**通用引用形参**的函数，无论是普通函数还是成员函数（尤其是构造函数），进行重载都会导致一系列问题，尤其是传入参数与重载函数的参数类型不能完全匹配时。但是也有一些方法，可以代替通用引用重载：

### 1. 放弃重载，使用新的函数名；

对于普通函数来说，可通过增加函数，也就是使用其他函数名称来完成（比如上面的`LogAndAdd(int idx)`可以更换为`LogAndAddIdx(int idx)`；

但是对于构造函数来说，因为函数名是固定的，所以不能使用这种方法。

### 2. 放弃完美转发，使用`const T&`

将传递通用引用替换为传递`lvalue-refrence-to-const`；其实是明确了自定义函数的类型，减少类型推导发生的非预期内调用。

该方法有可能的问题就是不能实现完美转发，如下代码：

`Sample sample(std::string("hello world"));` 此时传入参数是个右值，在调用`Sample(const std::string& test)`的`m_test(test)`时候还是会发生一次拷贝，当然我们是很希望传右值的时候可以省略掉拷贝代价；

如果传入参数是个左值，当然这次拷贝就不需要省略了。

```c++
std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
class Sample {
 public:
  explicit Sample(const std::string& test) : m_test(test) { std::cout << "Sample(const std::string& test)\n"; }
  explicit Sample(int idx) : m_test(map_idx_2_name[idx]) { std::cout << "Sample(int idx)\n"; }
 public:
  std::string m_test;
};
int main() {
  Sample sample(std::string("hello world"));
  int a = 1;
  Sample sample1(a);
  short b = 2;
  Sample sample2(b);
}
```

### 3. 按值传参；

传值的方式本质上还是**进一步明确了用户定义函数的形参类型**，限制了根据实参类型选择调用哪个函数。

比如说下面的代码，明确（参数类型明确）定义了两个函数`Sample(std::string test)`和`Sample(int idx)`，这样子 类`string`和`整型`的参数会区分调用这两个函数。

当然，对于`Sample(std::string test)`调用来说，传参会有拷贝操作。

```c++
std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
class Sample {
 public:
  explicit Sample(std::string test) : m_test(std::move(test)) { std::cout << "Sample(std::string test)\n"; }
  explicit Sample(int idx) : m_test(map_idx_2_name[idx]) { std::cout << "Sample(int idx)\n"; }
 public:
  std::string m_test;
};
int main() {
  Sample sample(std::string("hello world"));
  int a = 1;
  Sample sample1(a);
  short b = 2;
  Sample sample2(b);
}
```

### 4. 使用`tag dispatch`

> 什么是`tag dispatch`？附录中有介绍

上面的方法已经展示了传递`const T&`以及按值传递都不支持完美转发。如果在完美转发这方面有明确需要的话，有什么方式呢？

这种方法需要查看所有重载函数的所有形参以及调用者的所有传入实参，考虑所有形参/实参的组合，设计函数来合理分发如何调用。

如下面代码所示，我们首先需要一个分发函数，该分发函数的作用就是根据**所有形参/实参**的组合，判断输入形参的类型来分发调用不同的重载函数。

```c++
std::vector<std::string> names;

// 被重载的函数
template <typename T>
void logAndAddImpl(T&& name, std::false_type) {
  names.emplace_back(std::forward<T>(name));
}

std::string nameFromIdx(int idx) { return "helloworld"; }
// 被重载的函数
void logAndAddImpl(int idx, std::true_type) { names.emplace_back(nameFromIdx(idx)); }

// 负责分发的函数(在编译期就可以确定调用哪一个重载函数)
template <typename T>
void logAndAdd(T&& name) {
  logAndAddImpl(std::forward<T>(name), std::is_integral<typename std::remove_reference<T>::type>());
}
```

### 5. 约束使用通用引用的模板

> 这里主要用到了 SFINAE 技术，附录有简单介绍

通过`std::enable_if`来判断输入参数的类型，并决定是否使用该通用引用形式的模板重载函数。

```c++
std::string nameFromIdx(int idx);

class Person {
 public:
  template <typename T, typename = std::enable_if_t<!std::is_base_of<Person, std::decay_t<T>>::value && !std::is_integral<std::remove_reference_t<T>>::value>>
  explicit Person(T&& n) : name(std::forward<T>(n)) {}

  explicit Person(int idx) : name(nameFromIdx(idx)) {}

 private:
  std::string name;
};
```

## Item 28: Understand reference collapsing

引用折叠：是一个与模板和类型推导相关的概念。具体内容就是，无论你有多少层的引用，它们都会折叠成一个单一的引用（左值引用或者右值引用）。

折叠规则：如果多个引用中任一引用均为左值引用，则结果为左值引用。否则，结果为右值引用。

主要会发生在四种情况下：模板实例化（常见场景），`auto`类型推导，`typedef`与别名声明的创建和使用，`decltype`。

### 1. 模板实例化

```c++
template <typename T>
void foo(T&& t) {}

int main() {
  int a = 0;
  foo(a);  // a 是个左值；T被推导为int&，T&&折叠为int&
  foo(1);  // 1 是个右值；T被推导为int，T&&折叠为int&&
}
```

### 2. `auto`类型推导

```c++
auto&& b = a;  // b 的类型为 int&
auto&& c = 1;  // c 的类型为 int&&
```

### 3. `typedef`与别名声明的创建和使用

```c++
template <typename T>
class Widget {
 public:
  typedef T&& RvalueRefToT;
};

int main() {
  int a = 10;
  Widget<int&>::RvalueRefToT b = a;   // T 的类型为 int&，T&&=int& && 折叠为 int&, b 的类型为 int&
  Widget<int&&>::RvalueRefToT c = 1;  // T 的类型为 int&&，T&&=int&& && 折叠为 int&&, c 的类型为 int&&
}
```

### 4. `decltype`

```c++
int&& a = 10;
decltype(a)&& b = 20;  // b 的类型为 int&&
decltype(a)& c = a;    // c 的类型为 int&
```

这里重点讲解下`std::forward`，完美转发：可以将一个函数的形参原本值类别转发给内部的另一个函数。

```c++
class Sample {};

void someFunc(Sample& sample) { std::cout << "void someFunc(Sample& sample)\n"; }
void someFunc(Sample&& sample) { std::cout << "void someFunc(Sample&& sample)\n"; }

template <typename T>
void f(T&& fParam) {
  someFunc(std::forward<T>(fParam));  //转发fParam到someFunc
}

int main() {
  Sample s;
  f(s);
  f(Sample());
}
```

它的实现本质上就是引用折叠 + `static_cast`；

上面代码中，对函数 `f` 传递 `s` 时，因为 `s` 是个左值，此时 `T` 推导类型为 `Sample&`，调用 `std::forward` 的 `T` 会推导为 `Sample&`，那 `static_cast<Sample& &&>`的结果就是 `Sample&`；依然是个左值；

对函数 `f` 传递 `Sample()` 时，因为 `Sample()` 是个右值，此时 `T` 推导类型为 `Sample`，调用 `std::forward` 的 `T` 会推导为 `Sample`，那 `static_cast<Sample &&>`的结果就是 `Sample&&`；依然是个右值。

```c++
template<typename T>
T&& forward(typename remove_reference<T>::type& param){
    return static_cast<T&&>(param);
}
```

## Item 29: Assume that move operations are not present, not cheap, and not used

编写代码时应该假定移动操作不存在，成本高，未被使用。除了那些你可以明确你代码中的类型可支持移动操作。

### 1. `std::array`

对于`std::vector`来说，其元素是分配在堆内存中，内部包含了一个对所持内存的指针；那对于`std::vector`来说，`move`操作只需要更改指针指向即可了。其`move`代价是常量的。

对于`std::array`来说，其内部依旧是存储在栈内存中的数组；`move`操作还是需要对元素进行一个一个的拷贝。其`move`代价是线性的。

```c++
struct array {
    T elems[N]; // 包含 N 个元素的数组
}
```

### 2. `std::string`

其内部也是维护了一个指向对内存的指针，它也是提供了常数时间的移动操作和线性时间的复制操作。但是C++存在`SSO (Small String Optimization)`，当字符串的长度小于某个固定阈值（通常是 15 或 23 个字符，取决于实现和平台）时，`std::string` 会直接在其内部存储空间中存储字符串，而不是在堆上分配内存。

移动这种存储的字符串并不比复制操作更快。

### 3. 移动操作未声明`noexcept`

在 C++ 中，如果移动构造函数和移动赋值操作符没有被标记为 `noexcept`，那么在某些情况下可能会导致性能下降，甚至可能导致意外的行为。

1. 性能问题：标准库容器，如 `std::vector`，在进行重新分配操作时，如果元素的移动构造函数被标记为 `noexcept`，那么它会选择移动元素而不是复制元素。这通常会提高性能，因为移动操作通常比复制操作更快。然而，如果移动构造函数没有被标记为 `noexcept`，那么 std::vector 会选择复制元素，即使移动操作是有效的。这是因为如果移动操作抛出异常，那么 `std::vector` 将无法保证其强异常安全性。

2. 异常安全问题：如果移动操作抛出异常，那么可能会导致数据丢失或程序崩溃。例如，如果你在 `std::vector` 的重新分配过程中抛出异常，那么 `std::vector` 可能会处于一个无效的状态。

因此，如果你的移动操作不会抛出异常，那么最好将它们标记为 `noexcept`。这样可以确保标准库容器能够正确地使用移动操作，从而提高性能。同时，这也可以避免因移动操作抛出异常而导致的问题。

具体看下面的代码，自定义类`Sample`的移动构造函数声明了`noexcept`和未声明`noexcept`的代码输出区别：

```c++
#include <iostream>

class Sample {
 public:
  Sample() {}
  Sample(const Sample& sample) { std::cout << "Sample(const Sample& sample)\n"; }
  Sample(Sample&& sample) { std::cout << "Sample(Sample&& sample)\n"; }
};

int main() {
  std::vector<Sample> vecs;
  vecs.reserve(3);
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
}

// Sample(Sample&& sample)
// vecs.emplace_back:1
// Sample(Sample&& sample)
// vecs.emplace_back:2
// Sample(Sample&& sample)
// vecs.emplace_back:3
// Sample(Sample&& sample)
// Sample(const Sample& sample)
// Sample(const Sample& sample)
// Sample(const Sample& sample)
// vecs.emplace_back:4
```

```c++
#include <iostream>

class Sample {
 public:
  Sample() {}
  Sample(const Sample& sample) { std::cout << "Sample(const Sample& sample)\n"; }
  Sample(Sample&& sample) noexcept { std::cout << "Sample(Sample&& sample)\n"; }
};

int main() {
  std::vector<Sample> vecs;
  vecs.reserve(3);
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
  vecs.emplace_back(Sample());
  std::cout << "vecs.emplace_back:" << vecs.size() << "\n";
}

// Sample(Sample&& sample)
// vecs.emplace_back:1
// Sample(Sample&& sample)
// vecs.emplace_back:2
// Sample(Sample&& sample)
// vecs.emplace_back:3
// Sample(Sample&& sample)
// Sample(Sample&& sample)
// Sample(Sample&& sample)
// Sample(Sample&& sample)
// vecs.emplace_back:4
```

## 附录

### 1. `tag dispatch`

`Tag dispatch`是C++中的一种技术，用于在**编译期**选择合适的函数，基于其参数的属性或类型。

有些场景，我们希望通过不同的参数来控制调用不同的函数，比如说：通过传入的参数`tag`赋不同的值来调用不同的函数，下述代码是在运行期决定调用的`f1`还是`f2`。

```c++
void f1() {}
void f2() {}
void func(int tag) {
  if (0 == tag) {
    f1();
  } else if (1 == tag) {
    f2();
  }
}
```

利用`tag dispath`的方式就是，下面的代码中使用`std::true_type`和`std::false_type`作为`tag`在编译期推导出类型后选择合适的函数：

```c++
void f(int a, std::true_type t) { std::cout << "f(int a, std::true_type t)\n"; }
void f(int a, std::false_type f) { std::cout << "f(int a, std::false_type f)\n"; }

int main() {
  f(1, std::true_type());  // std::true_type()在编译期可以确定类型，类型确定之后调用哪个 f 函数也就确定了
  f(2, std::false_type());
  // f(int a, std::true_type t)
  // f(int a, std::false_type f)
}
```

### 2. `SFINAE`

`SFINAE` 是 C++ 中的一个术语，全称是 "Substitution Failure Is Not An Error"（替换失败并非错误）。这是一种**编译器处理模板**的方式。

它的基本思想是：在尝试实例化一个模板时，如果某个类型不能满足模板的要求（即类型替换失败），那么这个模板就会被编译器丢弃，而不会产生编译错误。编译器会继续寻找其他可以匹配的模板。

这种机制允许程序员创建多个模板，每个模板处理不同的类型或类型组合，而不必担心类型不匹配的问题。

```c++
#include <iostream>
#include <type_traits>

// 这个模板函数处理整数类型
template <typename T, std::enable_if_t<std::is_integral<T>::value, int> = 0>
void foo(T t) {
    std::cout << t << " is an integral type.\n";
}

// 这个模板函数处理非整数类型
template <typename T, std::enable_if_t<!std::is_integral<T>::value, int> = 0>
void foo(T t) {
    std::cout << t << " is not an integral type.\n";
}

int main() {
    foo(10);  // 输出: 10 is an integral type.
    foo(3.14);  // 输出: 3.14 is not an integral type.
    return 0;
}
```

在这个例子中，`std::enable_if_t` 是一个类型特性，它根据条件来启用或禁用模板。`std::is_integral<T>::value` 是一个编译时常量，如果 `T` 是整数类型，它的值为 `true`，否则为 `false`。因此，当我们尝试用一个整数类型调用 `foo` 函数时，第一个模板函数会被实例化，而第二个模板函数由于 `SFINAE` 而被丢弃。反之亦然。