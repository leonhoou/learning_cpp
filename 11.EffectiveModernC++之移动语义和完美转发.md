## Item 23: Understand `std::move` and `std::forward`

### 如何理解`std::move`和`std::forward`：

1. `std::move`不移动（move）任何东西，`std::forward`也不转发（forward）任何东西，仅仅是**执行转换（cast）的函数**（事实上是函数模板）;
2. `std::move`无条件的将它的实参转换为右值，而`std::forward`只在特定情况满足时下进行转换。

`std::move`在 C++11 中的实现方式： 注意到该函数的返回值类型是`std::remove_reference<T>::type&&`，一个右值引用。

```c++
template <typename T>
typename std::remove_reference<T>::type&& move(T&& param) {
  using ReturnType = typename std::remove_reference<T>::type&&;
  return static_cast<ReturnType>(param);
}
```

`std::move`在 C++14 中的实现方式：使用`decltype(auto)`自动推到返回值类型。

```c++
template <typename T>
decltype(auto) move(T&& param) {
  using ReturnType = std::remove_reference_t<T>&&;
  return static_cast<ReturnType>(param);
}
```

### `remove_reference`是啥

其中，`remove_reference`的实现代码如下所示，其实就是针对不同的`T`,`T&`,`T&&`，均可以返回去掉引用修饰符的`T`（当然`const`属性还是会被保留下来）。

```c++
template<class T> struct remove_reference { typedef T type; };
template<class T> struct remove_reference<T&> { typedef T type; };
template<class T> struct remove_reference<T&&> { typedef T type; };

remove_reference<Test>::type a1;          // Test a1;
remove_reference<const Test>::type a2;    // const Test a2;
remove_reference<Test&>::type b1;         // Test b1;
remove_reference<const Test&>::type b2;   // const Test b2;
remove_reference<Test&&>::type c1;        // Test c1;
remove_reference<const Test&&>::type c2;  // const Test c2;
```

### `std::move`本质上做了啥

**注意**：`std::move`只是把一个对象`cast`成了一个可供移动的候选者，真正的移动操作不一定会发生。举个例子：

```c++
class Test {
 public:
  Test() { std::cout << "default constructor\n"; }
  Test(const Test& other) { std::cout << "copy constructor\n"; }
  void operator=(const Test& other) { std::cout << "copy operator=\n"; }
  Test(Test&& other) { std::cout << "move constructor\n"; }
  void operator=(Test&& other) { std::cout << "move operator=\n"; }
  ~Test() = default;
};

class Sample {
 public:
  /**
   * 这里虽然使用了 std::move，但是并不会调用 test 的移动构造
   * 因为这里 test 是 const 修饰的；而 Test 类的移动构造函数的参数是非 const 的。
   */
  Sample(const Test test) : m_test(std::move(test)) {}

 public:
  Test m_test;
};

int main() {
  Test test;
  Sample sample(test);
  // default constructor
  // copy constructor
  // copy constructor
}
```

所以说，要注意这几点：

1. 不要在你希望能移动对象的时候，声明他们为`const`。对`const`对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move`不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。

### `std::forward`本质上又做了啥

一般用法：**引用转发**，最常见的情景是一个模板函数，接收一个通用引用形参，并将该参数传递给 内部另外的函数。

```c++
void process(const Test& lvalArg) { std::cout << "dealing with lvalue\n"; }
void process(Test&& rvalArg) { std::cout << "dealing with rvalue\n"; }

/**
 * 注：即使传入参数 param 为右值，这里的 param 自己本身依旧是个左值；
 * 那 process 在未引用转发时，调用的一直都是 void process(const Test& lvalArg);
 * 为了使得内部函数 process 调用时也可以保持 param 的左右值属性，固使用 std::forward
 */
template <typename T>
void logAndProcess(T&& param) {
  auto now = std::chrono::system_clock::now();
  auto now_time = std::chrono::system_clock::to_time_t(now);
  std::cout << "Calling process time:" << std::ctime(&now_time);
  process(std::forward<T>(param));
}

int main() {
  Test test;
  logAndProcess(test);            // 传入左值参数，内部函数 process 处理的参数 param 同样为左值
  logAndProcess(std::move(test));  // 传入右值参数，内部函数 process 处理的参数 param 同样为右值
}
```

## Item 24: Distinguish universal references from rvalue references

通用引用：其类型声明看起来像一个右值引用`T&&`，但实际上它可能是一个左值引用或右值引用。这取决于所赋值的表达式。有两种情况：

1. 函数模板形参

```c++
template<typename T>
void f(T&& param);
```

2. `auto`声明符号

```c++
auto&& var2 = var1;
```

注意：通用引用必须是需要类型推导的。且传入值为右值时，`param`会推导为右值引用`T&&`；传入值为左值时，`param`会推导为左值引用`T&`。

注意以下类型非通用引用：

1. 形式必须满足`T&&`：`template <typename T> void f(std::vector<T>&& param);`，其中，`param`是一个右值引用；
2. 添加`const`修饰符：`template <typename T> void f(const T&& param);`，其中，`param`是一个右值引用（即使仅添加了`const`修饰符）；
3. 未类型推导：下面的代码中即使函数`push_back`的形参类型为`T&&`，但这里也并非通用引用；因为这里未涉及到类型推导，我们在定义该`vector`的时候，`T`的类型就已经确定了。

```c++
template<class T, class Allocator = allocator<T>>
class vector {
public:
    void push_back(T&& x);
}
```

但是，`std::vector`内部的`emplace_back`确实是通用引用；因为这里的`Args`参数是独立于`T`的，是针对函数`emplace_back`的需要推导的模板参数。

```c++
template<class T, class Allocator = allocator<T>>
class vector {
public:
    template <class... Args>
    void emplace_back(Args&&... args);
};
```

## Item 25: Use `std::move` on rvalue references, `std::forward` on universal references

对右值引用使用`std::move`，对通用引用使用`std::forward`。

下面通过代码来解释这两个情况是什么意思。

```c++
class Test {
 public:
  Test() { std::cout << "default constructor\n"; }
  Test(const Test& other) { std::cout << "copy constructor\n"; }
  void operator=(const Test& other) { std::cout << "copy operator=\n"; }
  Test(Test&& other) { std::cout << "move constructor\n"; }
  void operator=(Test&& other) { std::cout << "move operator=\n"; }
  ~Test() = default;
};

class Sample {
 public:
  Sample() = default;

  /**
   * 形参为右值引用时，将形参传递给其他对象时尽量利用其右值性，使用 std::move
   */
  Sample(Test&& test) : m_test(std::move(test)) {}

  /**
   * 形参为通用引用时，将形参传递给其他对象时，使用 std::forward（因为你也不确定形参是左值还是右值）
   */
  template <typename T>
  void SetTest(T&& test) {
    m_test = std::forward<T>(test);
  }

  Test ReturnTest1(Test&& test) { return std::move(test); }

  template <typename T>
  decltype(auto) ReturnTest2(T&& test) {
    return std::forward<T>(test);
  }

 public:
  Test m_test;
};

int main() {
  Test test1;
  Sample sample;
  std::cout << "--------\n";
  Test t1 = sample.ReturnTest2(test1);
  std::cout << "--------\n";
  Test t2 = sample.ReturnTest2(Test());
  // default constructor
  // default constructor
  // --------
  // copy constructor
  // --------
  // default constructor
  // move constructor
}
```

这里需要注意字符串字面量的右值引用和通用引用形式：毕竟本质上字符串字面量的类型还是 `const char[]`

所以说，需要注意通用引用和右值引用在这方面上的区别，通用引用还是存在类型推导的。

```c++
class Sample {
 public:
  Sample() = default;

  void SetName(const std::string& name) { m_name = name; }

  void SetName(std::string&& name) { m_name = std::move(name); }

  template <typename T>
  void SetName2(T&& name) {
    m_name = std::forward<T>(name);
  }

 public:
  std::string m_name;
};

int main() {
  Sample sample;
  // void Sample::SetName(std::__1::string &&name)，这里类型是 const char [12]，会先调用 string 的构造函数生成一个临时对象，再调用 SetName 的右值形式
  sample.SetName("hello world");
  // void Sample::SetName2<const char (&)[12]>(const char (&name)[12])，这里通用引用会自动推导出类型 const char [12]
  sample.SetName2("hello world");
}
```

这个注意点尤其是在`std::vector`中适用：`push_back`和`emplace_back`

```c++
int main() {
  std::vector<std::string> strs;
  // inline void push_back(std::string &&__x)
  // 会先经过 const char [] 到 std::string 的构造，再调用右值形式的 push_back
  strs.push_back("hello");
  // inline void emplace_back<const char (&)[6]>(const char (&__args)[6])
  // 直接调用 emplace_back
  strs.emplace_back("world");
}
```

## Item 26: Avoid overloading on universal references

需要避免在参数为通用引用的函数上重载。

主要原因是用户自定义的重载函数，因为一些参数的类型在调用时会发生隐式转换，这种场景会优先匹配到通用引用的函数，而恰好通用引用的函数行为和用户期许隐式转换调用的函数行为不一致。

对于通用引用形式形参来说，几乎可以精确匹配任何类型的实参。主要是有三种场景，普通函数、构造函数、继承场景；

首先是对于普通函数，我们看代码来说吧，

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
std::vector<std::string> names;

// 参数为通用引用的函数
template <typename T>
void LogAndAdd(T&& name) {
  names.emplace_back(std::forward<T>(name));
}

//  重载通用引用的函数
void LogAndAdd(int idx) { names.emplace_back(map_idx_2_name[idx]); }

int main() {
  // 以下三种情况的通用引用函数调用形式，说明了精确推导
  std::string petName("Darla");
  LogAndAdd(petName);                    // 函数模板实例化为：void LogAndAdd<std::string &>(std::string &name)
  LogAndAdd(std::string("Persephone"));  // 函数模板实例化为：void LogAndAdd<std::string>(std::string &&name)
  LogAndAdd("Patty Dog");                // 函数模板实例化为：void LogAndAdd<const char (&)[10]>(const char (&name)[10])

  int idx1 = 1;
  LogAndAdd(idx1);  // 精确调用 void LogAndAdd(int idx)
  short idx2 = 1;
  // 根据正常的重载解决规则，精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。
  // 这里会匹配到 void LogAndAdd(T&& name)，并不会匹配到 void LogAndAdd(int idx)，所以会报错
  LogAndAdd(idx2);  // 函数模板实例化为：void LogAndAdd<short &>(short &name)
}
```

再就是构造函数，

```c++
class Sample {
 public:
  // 参数为通用引用的构造函数
  template <typename T>
  Sample(T&& test) : m_test(std::forward<T>(test)) {}

  // 重载通用引用的构造函数
  Sample(int idx) : m_test(map_idx_2_name[idx]) {}

  // 拷贝构造函数和移动构造函数可能非用户定义，而是编译器自动生成的；如果编译器自动生成就很容易被我忽略掉
  Sample(const Sample& other) {}
  Sample(Sample&& other) {}

 public:
  std::string m_test;
};

int main() {
  int a = 1;
  short b = 2;
  Sample sample1(a);
  Sample sample2(b);  // 报错：调用Sample(T&& test)，无法直接用int来构造string

  Sample s1(a);
  Sample s2(s1);  // 报错：调用Sample(T&& test)，尝试使用 s1 来初始化 m_test，所以报错
  // 这里为啥报错？因为 s1 的类型是非 const 的，而拷贝构造函数是 const 的，所以会去匹配通用引用形式的构造函数
}
```

在存在继承关系的构造函数中，看

```c++
class Person {
 public:
  // 需要注释与不注释下面的代码看程序输出
  template <typename T>
  Person(T&& n) : name(std::forward<T>(n)) {
    std::cout << "Person(T&& n)\n";
  }
  Person() {}
  Person(const Person& person) { std::cout << "Person(const Person& person)\n"; }
  Person(Person&& person) { std::cout << "Person(Person &&person)\n"; }

 private:
  std::string name;
};

class SpecialPerson : public Person {
 public:
  SpecialPerson() {}
  SpecialPerson(const SpecialPerson& rhs) : Person(rhs) {}
  SpecialPerson(SpecialPerson&& rhs) : Person(std::move(rhs)) {}
};

int main() {
  SpecialPerson sp0 = SpecialPerson();
  SpecialPerson sp1 = SpecialPerson(sp0);             // Person没有通用引用构造函数时，调用父类的拷贝构造函数：Person(const Person& person)
  SpecialPerson sp2 = SpecialPerson(std::move(sp0));  // Person没有通用引用构造函数时，调用父类的移动构造函数：Person(Person &&person)

  SpecialPerson sp1 = SpecialPerson(sp0);             // Person有通用引用构造函数时，会类型推导然后调用通用引用类型的构造函数
  SpecialPerson sp2 = SpecialPerson(std::move(sp0));  // Person有通用引用构造函数时，会类型推导然后调用通用引用类型的构造函数
}
```


## Item 27: Familiarize yourself with alternatives to overloading on universal references

对使用**通用引用形参**的函数，无论是普通函数还是成员函数（尤其是构造函数），进行重载都会导致一系列问题，尤其是传入参数与重载函数的参数类型不能完全匹配时。但是也有一些方法，可以代替通用引用重载：

### 1. 放弃重载，使用新的函数名；

对于普通函数来说，可通过增加函数，也就是使用其他函数名称来完成（比如上面的`LogAndAdd(int idx)`可以更换为`LogAndAddIdx(int idx)`；

但是对于构造函数来说，因为函数名是固定的，所以不能使用这种方法。

### 2. 放弃完美转发，使用`const T&`

将传递通用引用替换为传递`lvalue-refrence-to-const`；其实是明确了自定义函数的类型，减少类型推导发生的非预期内调用。

该方法有可能的问题就是不能实现完美转发，如下代码：

`Sample sample(std::string("hello world"));` 此时传入参数是个右值，在调用`Sample(const std::string& test)`的`m_test(test)`时候还是会发生一次拷贝，当然我们是很希望传右值的时候可以省略掉拷贝代价；

如果传入参数是个左值，当然这次拷贝就不需要省略了。

```c++
std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
class Sample {
 public:
  explicit Sample(const std::string& test) : m_test(test) { std::cout << "Sample(const std::string& test)\n"; }
  explicit Sample(int idx) : m_test(map_idx_2_name[idx]) { std::cout << "Sample(int idx)\n"; }
 public:
  std::string m_test;
};
int main() {
  Sample sample(std::string("hello world"));
  int a = 1;
  Sample sample1(a);
  short b = 2;
  Sample sample2(b);
}
```

### 3. 按值传参；

传值的方式本质上还是**进一步明确了用户定义函数的形参类型**，限制了根据实参类型选择调用哪个函数。

比如说下面的代码，明确（参数类型明确）定义了两个函数`Sample(std::string test)`和`Sample(int idx)`，这样子 类`string`和`整型`的参数会区分调用这两个函数。

当然，对于`Sample(std::string test)`调用来说，传参会有拷贝操作。

```c++
std::unordered_map<int, std::string> map_idx_2_name{{1, "hello"}, {2, "world"}};
class Sample {
 public:
  explicit Sample(std::string test) : m_test(std::move(test)) { std::cout << "Sample(std::string test)\n"; }
  explicit Sample(int idx) : m_test(map_idx_2_name[idx]) { std::cout << "Sample(int idx)\n"; }
 public:
  std::string m_test;
};
int main() {
  Sample sample(std::string("hello world"));
  int a = 1;
  Sample sample1(a);
  short b = 2;
  Sample sample2(b);
}
```

### 4. 使用`tag dispatch`

> 什么是`tag dispatch`？附录中有介绍

上面的方法已经展示了传递`const T&`以及按值传递都不支持完美转发。如果在完美转发这方面有明确需要的话，有什么方式呢？

这种方法需要查看所有重载函数的所有形参以及调用者的所有传入实参，考虑所有形参/实参的组合，设计函数来合理分发如何调用。

如下面代码所示，我们首先需要一个分发函数，该分发函数的作用就是根据**所有形参/实参**的组合，判断输入形参的类型来分发调用不同的重载函数。

```c++
std::vector<std::string> names;

// 被重载的函数
template <typename T>
void logAndAddImpl(T&& name, std::false_type) {
  names.emplace_back(std::forward<T>(name));
}

std::string nameFromIdx(int idx) { return "helloworld"; }
// 被重载的函数
void logAndAddImpl(int idx, std::true_type) { names.emplace_back(nameFromIdx(idx)); }

// 负责分发的函数(在编译期就可以确定调用哪一个重载函数)
template <typename T>
void logAndAdd(T&& name) {
  logAndAddImpl(std::forward<T>(name), std::is_integral<typename std::remove_reference<T>::type>());
}
```

## Item 28: Understand reference collapsing

引用折叠：是一个与模板和类型推导相关的概念。具体内容就是，无论你有多少层的引用，它们都会折叠成一个单一的引用。

发生在四种情况下：模板实例化，`auto`类型推导，`typedef`与别名声明的创建和使用，`decltype`。

### 1. 模板实例化

```c++
template <typename T>
void foo(T&& t) {}

int main() {
  int a = 0;
  foo(a);  // a 是个左值；T被推导为int&，T&&折叠为int&
  foo(1);  // 1 是个右值；T被推导为int，T&&折叠为int&&
}
```

### 2. `auto`类型推导

```c++
auto&& b = a;  // b 的类型为 int&
auto&& c = 1;  // c 的类型为 int&&
```

### 3. `typedef`与别名声明的创建和使用

```c++
template <typename T>
class Widget {
 public:
  typedef T&& RvalueRefToT;
};

int main() {
  int a = 10;
  Widget<int&>::RvalueRefToT b = a;   // T 的类型为 int&，T&&=int& && 折叠为 int&, b 的类型为 int&
  Widget<int&&>::RvalueRefToT c = 1;  // T 的类型为 int&&，T&&=int&& && 折叠为 int&&, c 的类型为 int&&
}
```

### 4. `decltype`

```c++
int&& a = 10;
decltype(a)&& b = 20;  // b 的类型为 int&&
decltype(a)& c = a;    // c 的类型为 int&
```

## 附录

### 1. `tag dispatch`

`Tag dispatch`是C++中的一种技术，用于在**编译期**选择合适的函数，基于其参数的属性或类型。

有些场景，我们希望通过不同的参数来控制调用不同的函数，比如说：通过传入的参数`tag`赋不同的值来调用不同的函数，下述代码是在运行期决定调用的`f1`还是`f2`。

```c++
void f1() {}
void f2() {}
void func(int tag) {
  if (0 == tag) {
    f1();
  } else if (1 == tag) {
    f2();
  }
}
```

利用`tag dispath`的方式就是，下面的代码中使用`std::true_type`和`std::false_type`作为`tag`在编译期推导出类型后选择合适的函数：

```c++
void f(int a, std::true_type t) { std::cout << "f(int a, std::true_type t)\n"; }
void f(int a, std::false_type f) { std::cout << "f(int a, std::false_type f)\n"; }

int main() {
  f(1, std::true_type());  // std::true_type()在编译期可以确定类型，类型确定之后调用哪个 f 函数也就确定了
  f(2, std::false_type());
  // f(int a, std::true_type t)
  // f(int a, std::false_type f)
}
```
